// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.0
//   protoc               v5.27.2
// source: payment.proto

/* eslint-disable */
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import { Observable } from "rxjs";

export const protobufPackage = "payment";

export enum StatusType {
  ERROR = 0,
  OK = 1,
  UNRECOGNIZED = -1,
}

export enum PaymentType {
  CARD_TOKENS = 0,
  BANK_ACCOUNT = 1,
  UNRECOGNIZED = -1,
}

export enum PayerType {
  LEGAL = 0,
  INDIDVIDUAL = 1,
  FOREIGN = 2,
  UNRECOGNIZED = -1,
}

export interface RequestOrders {
  id: string[];
}

export interface RequestSessions {
  id: string[];
}

export interface ResponseOrders {
  ordersInfo: OrderInfo[];
}

export interface OrderInfo {
  id: string;
  paymentId: string;
  status: string;
  amount: number;
  type: string;
  sessionId: string;
  paymentDate: string;
  description: string;
  reciept: string;
}

export interface ResponseSessions {
  sessionInfo: SessionInfo[];
}

export interface SessionInfo {
  id: string;
  sessionId: string;
  status: string;
}

/** баланс */
export interface WalletDetails {
  amount: number;
  currency: string;
}

export interface Error {
  code: string;
  message: string;
}

export interface BalanceResponse {
  status: StatusType;
  wallets: WalletDetails[];
  error: Error | undefined;
}

export interface BalanceRequest {
  /** банк, по умолчанию банк 131 */
  bank: string;
}

export interface TaxReference {
  /** одного символа не хватило до uint32 */
  taxReference: number;
  /** банк, по умолчанию банк 131 */
  bank: string;
}

export interface CheckCheckSelfEmployedResponse {
  status: StatusType;
  error: Error | undefined;
  details: SelfEmployedDetails | undefined;
}

export interface SelfEmployedDetails {
  isBind: boolean;
  isSelfEmployed: boolean;
}

export interface Transaction {
  transactionId: string;
  /** банк, по умолчанию банк 131 */
  bank: string;
}

export interface ConfirmOrCancelResponse {
  status: StatusType;
  error: Error | undefined;
}

/** Создание сессии */
export interface PaymentSessionRequest {
  amount: number;
  payer: Payer | undefined;
  paymentType: PaymentType;
  details: PaymentDetails | undefined;
  recipientFullName: string;
  services: Service[];
  /** банк, по умолчанию банк 131 */
  bank: string;
}

export interface PaymentDetails {
  cardTokens?: CardTokens | undefined;
  bankAccount?: BankAccount | undefined;
}

export interface BankAccount {
  bik: string;
  bankAccount: string;
  fullName: string;
  description: string;
}

export interface Service {
  name: string;
  amount: string;
}

export interface CardTokens {
  numberHash: string;
  expirationDateHash: string;
  cardholderNameHash: string;
  securityCodeHash: string;
  widgetToken: string;
}

export interface Payer {
  payerId: number;
  payerType: PayerType;
  payerName: string;
  payerTaxNumber: number;
}

export interface PaymentSessionResponse {
  status: StatusType;
  error: Error | undefined;
  sessionId: string;
}

/** Создание сессии и получение токена карты */
export interface TokenRequest {
  /** банк, по умолчанию банк 131 */
  bank: string;
}

export interface TokenResponse {
  status: StatusType;
  error: Error | undefined;
  publicToken: string;
}

export interface RequestInfo {
  orderPaymentId: string[];
}

export interface ResponseInfo {
  ordersId: OrderInfo[];
}

export const PAYMENT_PACKAGE_NAME = "payment";

export interface paymentClient {
  getBalance(request: BalanceRequest): Observable<BalanceResponse>;

  checkSelfEmployed(request: TaxReference): Observable<CheckCheckSelfEmployedResponse>;

  confirmPayout(request: Transaction): Observable<ConfirmOrCancelResponse>;

  cancelPayout(request: Transaction): Observable<ConfirmOrCancelResponse>;

  createPaymentSession(request: PaymentSessionRequest): Observable<PaymentSessionResponse>;

  getTokenizedCardData(request: TokenRequest): Observable<TokenResponse>;

  getOrders(request: RequestOrders): Observable<ResponseOrders>;

  getSessions(request: RequestSessions): Observable<ResponseSessions>;
}

export interface paymentController {
  getBalance(request: BalanceRequest): Promise<BalanceResponse> | Observable<BalanceResponse> | BalanceResponse;

  checkSelfEmployed(
    request: TaxReference,
  ):
    | Promise<CheckCheckSelfEmployedResponse>
    | Observable<CheckCheckSelfEmployedResponse>
    | CheckCheckSelfEmployedResponse;

  confirmPayout(
    request: Transaction,
  ): Promise<ConfirmOrCancelResponse> | Observable<ConfirmOrCancelResponse> | ConfirmOrCancelResponse;

  cancelPayout(
    request: Transaction,
  ): Promise<ConfirmOrCancelResponse> | Observable<ConfirmOrCancelResponse> | ConfirmOrCancelResponse;

  createPaymentSession(
    request: PaymentSessionRequest,
  ): Promise<PaymentSessionResponse> | Observable<PaymentSessionResponse> | PaymentSessionResponse;

  getTokenizedCardData(request: TokenRequest): Promise<TokenResponse> | Observable<TokenResponse> | TokenResponse;

  getOrders(request: RequestOrders): Promise<ResponseOrders> | Observable<ResponseOrders> | ResponseOrders;

  getSessions(request: RequestSessions): Promise<ResponseSessions> | Observable<ResponseSessions> | ResponseSessions;
}

export function paymentControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = [
      "getBalance",
      "checkSelfEmployed",
      "confirmPayout",
      "cancelPayout",
      "createPaymentSession",
      "getTokenizedCardData",
      "getOrders",
      "getSessions",
    ];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("payment", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("payment", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const PAYMENT_SERVICE_NAME = "payment";
